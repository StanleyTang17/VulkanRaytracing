#version 450 core

// x-axis: left/right
// y-axis: up/down
// z-axis: front/back

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Sphere
{
    vec3 center;
    float radius;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
layout (binding = 1, rgba32f) uniform image2D image_data;

const vec3 proj_origin = vec3(0.0, 0.0, 0.0);
const vec3 proj_plane[3] = vec3[3](vec3(-1.0, -0.8, 1.0),   // bottom left corner
                                   vec3(1.0, 0.0, 0.0),     // "horizontal" direction
                                   vec3(0.0, 1.0, 0.0));    // "vertical" direction
const Sphere sphere = { vec3(0.0, 0.0, 2.0), 0.5 };

Ray get_ray(float s, float t); // returns the direction of a ray given x and y index
float hit_sphere(Ray ray, Sphere sphere); // check if a ray hits a sphere
vec3 ray_color(Ray ray, Sphere sphere); // returns the color of a ray

void main()
{
    Ray ray = get_ray(gl_GlobalInvocationID.x / 800.0 * 2.0, gl_GlobalInvocationID.y / 640.0 * 1.6);
    vec3 color = ray_color(ray, sphere);

	imageStore(image_data, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}

Ray get_ray(float s, float t)
{
    vec3 proj_point = proj_plane[0] + s * proj_plane[1] + t * proj_plane[2];
    Ray ray = { proj_origin, normalize(proj_point - proj_origin) };
    return ray;
}

float hit_sphere(Ray ray, Sphere sphere)
{
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = dot(ray.direction, oc) * 2.0;
    float c = dot(oc, oc) - (sphere.radius * sphere.radius);
    float discriminant = b * b - 4 * a * c;

    if (discriminant > 0) {
        return (-b - sqrt(discriminant)) / (2.0 * a);
    } else {
        return -1.0;
    }
}

vec3 ray_color(Ray ray, Sphere sphere)
{
    float t = hit_sphere(ray, sphere);
    if (t > 0.0) {
        vec3 N = normalize((ray.origin + t * ray.direction) - sphere.center);
        return 0.5 * vec3(N.x + 1.0, N.y + 1.0, N.z + 1.0);
    }
    t = 0.5 * (ray.direction.y + 1.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.1, 0.1, 1.0);
}