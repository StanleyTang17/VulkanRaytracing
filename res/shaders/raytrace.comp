#version 450 core

// x-axis: left/right
// y-axis: up/down
// z-axis: front/back

#define PI 3.1415926538

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Sphere
{
    vec3 center;
    float radius;
};

struct HitRecord
{
    vec3 point;
    vec3 normal;
    float t;
    bool front_face;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
layout (binding = 1, rgba32f) uniform image2D image_data;

const vec3 proj_origin = vec3(0.0, 0.0, 0.0);
const vec3 proj_plane[3] = vec3[3](vec3(-1.0, -0.8, 1.0),   // top right corner
                                   vec3(1.0, 0.0, 0.0),     // "horizontal" direction
                                   vec3(0.0, 1.0, 0.0));    // "vertical" direction
const Sphere spheres[2] = {
    { vec3(0.0, 0.0, 2.0), 0.5 },
    { vec3(0.0, -100.5, -1.0), 100.0 }
};
const uint num_spheres = 2;
const uint num_samples = 100;

uint state = (gl_GlobalInvocationID.x * 1973 + gl_GlobalInvocationID.y * 9277);

float rand(inout uint state); // generate a random float between 0.0 and 1.0
vec3 rand_in_unit_sphere(inout uint state); // generate a random point in a unit sphere
Ray get_ray(float s, float t); // returns the direction of a ray given x and y index
bool sphere_hit(Ray ray, Sphere sphere, float t_min, float t_max, inout HitRecord hit_record); // check if a ray hits a sphere
bool scene_hit(Ray ray, float t_min, float t_max, inout HitRecord hit_record); // check if a ray hits an object in the scene
vec3 ray_color(Ray ray, int depth); // returns the color of a ray

void main()
{
    vec3 pixel_color = vec3(0.0);

    for (uint i = 0; i < num_samples; ++i) {
        Ray ray = get_ray(
            (gl_GlobalInvocationID.x + rand(state)) / 800.0 * 2.0,
            (gl_GlobalInvocationID.y + rand(state)) / 640.0 * 1.6
        );

        pixel_color += ray_color(ray, 50);
    }

    pixel_color /= num_samples;

	imageStore(image_data, ivec2(gl_GlobalInvocationID.xy), vec4(pixel_color, 1.0));
}

Ray get_ray(float s, float t)
{
    vec3 proj_point = proj_plane[0] + s * proj_plane[1] + t * proj_plane[2];
    Ray ray = { proj_origin, normalize(proj_point - proj_origin) };
    return ray;
}

bool sphere_hit(Ray ray, Sphere sphere, float t_min, float t_max, inout HitRecord hit_record)
{
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(ray.direction, oc);
    float c = dot(oc, oc) - (sphere.radius * sphere.radius);
    float discriminant = half_b * half_b - a * c;

    if (discriminant < 0.0) return false;

    float sqrtd = sqrt(discriminant);
    float t = (-half_b - sqrtd) / a;
    if (t < t_min || t_max < t) {
        t = (-half_b + sqrtd) / a;
        if (t < t_min || t_max < t) return false;
    }

    hit_record.t = t;
    hit_record.point = ray.origin + t * ray.direction;

    vec3 outward_normal = (sphere.center - hit_record.point) / sphere.radius;

    if (dot(ray.direction, outward_normal) < 0.0) {
        // ray is outside the sphere
        hit_record.normal = outward_normal;
        hit_record.front_face = true;
    } else {
        // ray is inside the sphere
        hit_record.normal = -outward_normal;
        hit_record.front_face = false;
    }
    
    return true;
}

bool scene_hit(Ray ray, float t_min, float t_max, inout HitRecord hit_record)
{
    HitRecord tmp_hit_record;
    bool hit = false;
    float closest_t = t_max;

    for (uint i = 0; i < num_spheres; ++i) {
        if (sphere_hit(ray, spheres[i], t_min, closest_t, tmp_hit_record)) {
            hit = true;
            closest_t = tmp_hit_record.t;
            hit_record = tmp_hit_record;
        }
    }

    return hit;
}

float rand(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    
    return (state & 0xffffff) / 16777216.0f;
}

vec3 rand_in_unit_sphere(inout uint state)
{
    float r = pow(rand(state), 1.0/3.0);

    float u = rand(state);
    float v = rand(state);
    float theta = u * 2.0 * PI;
    float phi = acos(2.0 * v - 1.0);
    
    float sinTheta = sin(theta);
    float cosTheta = cos(theta);
    float sinPhi = sin(phi);
    float cosPhi = cos(phi);

    float x = r * sinPhi * cosTheta;
    float y = r * sinPhi * sinTheta;
    float z = r * cosPhi;

    return vec3(x, y, z);
}

vec3 ray_color(Ray ray, int depth)
{
    HitRecord hit_record;
    float scatter_factor = 1.0;

    for (int i = 0; i < depth; ++i) {
        if (scene_hit(ray, 0.00001, 100000000000.0, hit_record)) {
            scatter_factor *= 0.5;

            // generate scattered ray
            vec3 target = hit_record.point + hit_record.normal + rand_in_unit_sphere(state);
            ray.direction = normalize(target - ray.origin);
            ray.origin = hit_record.point;
        } else {
            float t = 0.5 * (ray.direction.y + 1.0);
            return scatter_factor * ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
        }
    }
    
    // exceeded depth
    return vec3(0.0);
}