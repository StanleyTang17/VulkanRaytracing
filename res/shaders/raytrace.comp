#version 450 core

// x-axis: left/right
// y-axis: up/down
// z-axis: front/back

#define PI 3.1415926538

// material types
#define MAT_LAMBERTIAN  0
#define MAT_METAL       1

#define NUM_MATERIALS   4
#define NUM_SPHERES     4

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct Material
{
    int type;
    vec3 albedo;
    float metal_fuzz;
};

struct Sphere
{
    vec3 center;
    float radius;
    int material_idx;
};

struct HitRecord
{
    vec3 point;
    vec3 normal;
    float t;
    bool front_face;
    int material_idx;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;
layout (binding = 1, rgba32f) uniform image2D image_data;

const Material materials[NUM_MATERIALS] = {
    { MAT_LAMBERTIAN,   vec3(0.8, 0.8, 0.0),    0.0 }, // ground material
    { MAT_METAL,        vec3(0.8, 0.8, 0.8),    0.3 }, // left sphere material
    { MAT_LAMBERTIAN,   vec3(0.7, 0.3, 0.3),    0.0 }, // middle sphere material
    { MAT_METAL,        vec3(0.8, 0.6, 0.2),    1.0 }  // right sphere material
};
const Sphere spheres[NUM_SPHERES] = {
    { vec3(0.0, -100.5, 2.0),   100.0,  0 }, // ground sphere
    { vec3(-1.0, 0.0, 2.0),     0.5,    1 }, // left sphere
    { vec3(0.0, 0.0, 2.0),      0.5,    2 }, // middle sphere
    { vec3(1.0, 0.0, 2.0),      0.5,    3 }  // right sphere
};
const uint num_samples = 300;
const uint screen_width = 1600;
const uint screen_height = 912;
const float aspect_ratio = 1.0 * screen_width / screen_height;
const float viewport_width = 2.0;
const float viewport_height = viewport_width / aspect_ratio;

const vec3 proj_origin = vec3(0.0, 0.0, 0.0);
const vec3 proj_plane[3] = vec3[3](vec3(-viewport_width / 2.0, -viewport_height / 2.0, 1.0),   // top left corner
                                   vec3(1.0, 0.0, 0.0),     // "horizontal" direction
                                   vec3(0.0, 1.0, 0.0));    // "vertical" direction

uint state = (gl_GlobalInvocationID.x * 1973 + gl_GlobalInvocationID.y * 9277);

float rand(inout uint state); // generate a random float between 0.0 and 1.0
vec3 rand_in_unit_sphere(inout uint state); // generate a random point in a unit sphere
vec3 rand_unit_vector(inout uint state); // generate a random unit vector
Ray get_ray(float s, float t); // returns the direction of a ray given x and y index
bool sphere_hit(Ray ray, Sphere sphere, float t_min, float t_max, inout HitRecord hit_record); // check if a ray hits a sphere
bool scene_hit(Ray ray, float t_min, float t_max, inout HitRecord hit_record); // check if a ray hits an object in the scene
bool lamb_scatter(inout Ray ray, inout vec3 attenuation, Material material); // scatter lambertian ray
bool metal_scatter(inout Ray ray, inout vec3 attenuation, Material material); // scatter metal ray
vec3 ray_color(Ray ray, int depth); // returns the color of a ray
void write_color(ivec2 index, vec4 color); // write color to image

void main()
{
    vec3 pixel_color = vec3(0.0);

    for (uint i = 0; i < num_samples; ++i) {
        Ray ray = get_ray(
            (gl_GlobalInvocationID.x + rand(state)) / screen_width * viewport_width,
            (gl_GlobalInvocationID.y + rand(state)) / screen_height * viewport_height
        );

        pixel_color += ray_color(ray, 50);
    }

    write_color(ivec2(gl_GlobalInvocationID.xy), vec4(pixel_color, 1.0));
}

Ray get_ray(float s, float t)
{
    vec3 proj_point = proj_plane[0] + s * proj_plane[1] + t * proj_plane[2];
    Ray ray = { proj_origin, normalize(proj_point - proj_origin) };
    return ray;
}

bool sphere_hit(Ray ray, Sphere sphere, float t_min, float t_max, inout HitRecord hit_record)
{
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(ray.direction, oc);
    float c = dot(oc, oc) - (sphere.radius * sphere.radius);
    float discriminant = half_b * half_b - a * c;

    if (discriminant < 0.0) return false;

    float sqrtd = sqrt(discriminant);
    float t = (-half_b - sqrtd) / a;
    if (t < t_min || t_max < t) {
        t = (-half_b + sqrtd) / a;
        if (t < t_min || t_max < t) return false;
    }

    hit_record.t = t;
    hit_record.point = ray.origin + t * ray.direction;
    hit_record.material_idx = sphere.material_idx;

    vec3 outward_normal = (sphere.center - hit_record.point) / sphere.radius;

    if (dot(ray.direction, outward_normal) < 0.0) {
        // ray is outside the sphere
        hit_record.normal = outward_normal;
        hit_record.front_face = true;
    } else {
        // ray is inside the sphere
        hit_record.normal = -outward_normal;
        hit_record.front_face = false;
    }
    
    return true;
}

bool scene_hit(Ray ray, float t_min, float t_max, inout HitRecord hit_record)
{
    HitRecord tmp_hit_record;
    bool hit = false;
    float closest_t = t_max;

    for (uint i = 0; i < NUM_SPHERES; ++i) {
        if (sphere_hit(ray, spheres[i], t_min, closest_t, tmp_hit_record)) {
            hit = true;
            closest_t = tmp_hit_record.t;
            hit_record = tmp_hit_record;
        }
    }

    return hit;
}

float rand(inout uint state)
{
    state ^= state << 13;
    state ^= state >> 17;
    state ^= state << 5;
    
    return (state & 0xffffff) / 16777216.0f;
}

vec3 rand_in_unit_sphere(inout uint state)
{
    float r = pow(rand(state), 1.0/3.0);

    float u = rand(state);
    float v = rand(state);
    float theta = u * 2.0 * PI;
    float phi = acos(2.0 * v - 1.0);
    
    float sinTheta = sin(theta);
    float cosTheta = cos(theta);
    float sinPhi = sin(phi);
    float cosPhi = cos(phi);

    float x = r * sinPhi * cosTheta;
    float y = r * sinPhi * sinTheta;
    float z = r * cosPhi;

    return vec3(x, y, z);
}

vec3 rand_unit_vector(inout uint state)
{
    return normalize(rand_in_unit_sphere(state));
}

bool lamb_scatter(inout Ray ray, HitRecord hit_record, inout vec3 color, Material material)
{
    vec3 scatter_direction = normalize(hit_record.normal + rand_unit_vector(state));

    ray.direction = scatter_direction;
    ray.origin = hit_record.point;
    color *= material.albedo;

    return true;
}

bool metal_scatter(inout Ray ray, HitRecord hit_record, inout vec3 color, Material material)
{
    vec3 reflected = reflect(ray.direction, hit_record.normal);

    if (dot(reflected, hit_record.normal) > 0) {
        ray.direction = normalize(reflected + material.metal_fuzz * rand_in_unit_sphere(state));
        ray.origin = hit_record.point;
        color *= material.albedo;

        return true;
    } else {
        color = vec3(0.0);

        return false;
    }
}

vec3 ray_color(Ray ray, int depth)
{
    int i;
    HitRecord hit_record;
    vec3 color = vec3(1.0);

    for (i = 0; i < depth; ++i) {
        if (scene_hit(ray, 0.001, 100000000000.0, hit_record)) {
            Material material = materials[hit_record.material_idx];
            bool scattered = false;

            if (material.type == MAT_LAMBERTIAN) {
                scattered = lamb_scatter(ray, hit_record, color, material);
            } else if (material.type == MAT_METAL) {
                scattered = metal_scatter(ray, hit_record, color, material);
            }

            if (!scattered)
                break;
        } else {
            float t = 0.5 * (ray.direction.y + 1.0);
            vec3 default_color = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
            color *= default_color;
            break;
        }
    }
    
    // exceeded depth
    if (i < depth) {
        return color;
    } else {
        return vec3(0.0);
    }
}

void write_color(ivec2 index, vec4 color)
{
    float r = color.r;
    float g = color.g;
    float b = color.b;

    float scale = 1.0 / num_samples;
    r = sqrt(scale * r);
    g = sqrt(scale * g);
    b = sqrt(scale * b);

    color = vec4(r, g, b, color.a);
    imageStore(image_data, index, color);
}